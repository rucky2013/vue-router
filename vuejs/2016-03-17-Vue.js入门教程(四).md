以官方的HackerNews为例，现在到了最关键的一部分，*.vue组件.

###0x00 
将html/css/js写在一个文件中，看起来确实有点不好看，但作为组件来说，这其实是一个帕累托最优的方案。(请允许我用一个经济学名词装一下哔... =_=)

不管在<template></template>模板中还是js/style, 都可以指定需要使用的预处理器，比如像CSS，我就喜欢用SASS写。

###0x01 transition
transition是Vue.js 的一个动画过渡系统，可在元素从DOM中插入或移除时自动应用过渡效果，类似jQuery的fadeIn/fadeOut。
```javascript
<div transition="my-transition">Transition</div>
```
当在元素中设置了id "transition"，Vue.js会尝试Vue.transition(id,hooks)或者transitions选项来注册，如果找到了这个id，便会在过渡的不同阶段调用相应的钩子函数。

如果目标元素有CSS过渡或动画，那么Vue.js会在合适的实际删除或添加CSS动画类名。

如果Vue.js没有找到相应的transition钩子函数，也没检测到CSS过渡/动画，DOM的操作将会在下一帧立即执行。

官网中CSS过渡的Demo：
```javascript
<div transition="expand">Vue.js</div>
```
然后需要给transition添加相应的CSS规则
```javascript
//必需
.expand-transition {
	transition: height .3s ease;
	height: 30px;
	padding: 10px;
	overflow: hidden;
}
// 定义相应的进入和离开的状态
.expand-enter,.expand-leave {
	height: 0;
	padding: 0 10px;
	opacity: 0;
}
```
元素类名的添加和切换取决于transition的值，比如transition="fade"，将会有三个类名:
- .fade-transition 始终保留在元素上
- .fade-enter 定义进入过渡的开始状态，只应用一帧后立即删除。
- .fade-leave 定义离开过渡的结束状态，在离开过渡的开始生效，结束后删除。
- 如果transition特性没有值，类名默认是.v-transition,v-enter,v-leave...

###0x02 directive
类似Angular的ECMA指令,可以用Vue.directive(id,definition)方法注册一个全局自定义指令，也可以用组件的directives注册一个组件局部的自定义指令。

- bind: 只调用一次，在指令第一次绑定到元素上时调用。

- update：在 bind 之后立即以初始值为参数第一次调用，之后每当绑定值变化时调用，参数为新值与旧值。 

- unbind：只调用一次，在指令从元素上解绑时调用。

```javascript
Vue.directive('my-directive', {
  bind: function () {
    // 准备工作
    // 例如，添加事件处理器或只需要运行一次的高耗任务
  },
  update: function (newValue, oldValue) {
    // 值更新时的工作
    // 也会以初始值为参数调用一次
  },
  unbind: function () {
    // 清理工作
    // 例如，删除 bind() 添加的事件监听器
  }
})
```

Vue还有一个类似Angular的E指令，即指令可以当做一个轻量级组件。
```javascript
Vue.elementDirective('my-directive', {
  // API 同普通指令
  bind: function () {
    // 操作 this.el... el是原生的DOM
  }
})

// 使用
<my-directive></my-directive>
```


###0x03 filter
类似于自定义指令，可以用全局方法 Vue.filter() 注册一个自定义过滤器，它接收两个参数：过滤器 ID 和过滤器函数。过滤器函数以值为参数，返回转换后的值：

```javascript
Vue.filter('reverse', function (value) {
  return value.split('').reverse().join('')
})

<!-- 'abc' => 'cba' -->
<span v-text="message | reverse"></span>
```
因为Vue.js是双向绑定的，这里也介绍下双向过滤器。
```javascript
Vue.filter('currencyDisplay', {
  // model -> view
  // 在更新 `<input>` 元素之前格式化值
  read: function(val) {
    return '$'+val.toFixed(2)
  },
  // view -> model
  // 在写回数据之前格式化值
  write: function(val, oldVal) {
    var number = +val.replace(/[^\d.]/g, '')
    return isNaN(number) ? 0 : parseFloat(number.toFixed(2))
  }
})
```

###0x04 Component and ViewModel
Vue.js的组件可以局部注册也可以全局注册：
```javascript
var MyComponent = Vue.extend({
  // 选项...
})

// 全局注册组件，tag 为 my-component
Vue.component('my-component', MyComponent)
```

局部注册可以使用实例选项components注册：
```javascript
var Child = Vue.extend({ /* ... */ })

var Parent = Vue.extend({
  template: '...',
  components: {
    // <my-component> 只能用在父组件模板内
    'my-component': Child
  }
})
```

当然你也可以这么做：
```javascript
// 在一个步骤中扩展与注册
Vue.component('my-component', {
  template: '<div>A custom component!</div>'
})

// 局部注册也可以这么做
var Parent = Vue.extend({
  components: {
    'my-component': {
      template: '<div>A custom component!</div>'
    }
  }
})
```

但很多人都会喜欢用*.vue文件来统一管理一个组件，即CSS/HTML/JS统一放在一个*.vue文件，就近管理.

对于编写组件的时候我们需要注意几个小点：
1. HTML 特性不区分大小写。名字形式为 camelCase 的 prop 用作特性时，需要转为 kebab-case（短横线隔开）：
```javascript
Vue.component('my-component', {
  template: '<div>Hello</div>'
})

// 使用时应该这样:
<myComponent></myComponent>
```

2. 组件间若需要数据通信，Vue.js支持使用props属性进行绑定，默认是单向绑定。即当父组件的属性变化时，将传导给子组件，但是反过来不会。这是为了防止子组件无意修改了父组件的状态——这会让应用的数据流难以理解。不过，也可以使用 .sync 或 .once 绑定修饰符显式地强制双向或单次绑定：

```javascript
<!-- 默认为单向绑定 -->
<child :msg="parentMsg"></child>

<!-- 双向绑定 -->
<child :msg.sync="parentMsg"></child>

<!-- 单次绑定 -->
<child :msg.once="parentMsg"></child>
```

3. 虽然Vue.js支持数据和视图的同步更新，但也是基于依赖驱动的。Vue.js默认是异步更新DOM的。
即每当观察到数据变化时，Vue 就开始一个队列，将同一事件循环内所有的数据变化缓存起来。如果一个 watcher 被多次触发，只会推入一次到队列中。等到下一次事件循环，Vue 将清空队列，只进行必要的 DOM 更新。在内部异步队列优先使用 MutationObserver，如果不支持则使用 setTimeout(fn, 0)。

例如，设置了 vm.someData = 'new value'，DOM 不会立即更新，而是在下一次事件循环清空队列时更新。

```javascript
var vm = new Vue({
  el: '#example',
  data: {
    msg: '123'
  }
})
vm.msg = 'new message' // 修改数据
vm.$el.textContent === 'new message' // false
Vue.nextTick(function () {
  vm.$el.textContent === 'new message' // true
})
```

Vue.nextTick(vm.$nextTick) 在这里就是强制下一帧实行数据视图的更新，毕竟有时候我们希望数据更新后能立即更新DOM，虽然Vue.js鼓励开发者沿着数据驱动的思路，避免直接修改 DOM，但是有时确实要这么做。

###0x05 router-view
官网已经写的很详细了，这里的话我只是做个记录，仅做vue-router/github-api的一些demo演示


