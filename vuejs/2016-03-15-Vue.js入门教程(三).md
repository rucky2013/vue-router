###Show the code

```javascript
import Vue from 'vue'

import Router from 'vue-router'

import { domain, fromNow } from './filters'

import App from './components/App.vue'

import NewsView from './components/NewsView.vue'

import ItemView from './components/ItemView.vue'

import UserView from './components/UserView.vue'
```
在webpack.config.js中可以设置 require{extentions:['','js','vue']}来省略导入模块时的后缀，但第一个必须为空''

src/main.js
```javascript
// 这里用了ES6的对象解构，如：let {a, b} = {a:'A', b:'B'}; 
// console.log(a);      'A'
import {domain, fromNow} from './filters'
```

```javascript
// install router
Vue.use(Router)

// 若你不在这里全局注册filter，在其他组件使用时就需要及时引入'./filter'
Vue.filter('fromNow', fromNow)
Vue.filter('domain', domain)
```

```javascript
// router实例化
var router = new Router()

// 当路径匹配时，在<router-view></router-view> 会渲染其组件
router.map({
  '/news/:page': {
    component: NewsView
  },
  '/user/:id': {
    component: UserView
  },
  '/item/:id': {
    component: ItemView
  }
})
// 路由开始切换时调用的函数，可注册多个，路由切换时按注册顺序调用
router.beforeEach(function () {
  window.scrollTo(0, 0)
})

// 任何未匹配的路径都会使用这个路由
router.redirect({
  '*': '/news/1'
})

// 类似 new Vue({el: '#app'}), 这里是讲App.vue组件挂载在#app节点下,渲染后#app不会出现
router.start(App, '#app')
```


src/filter/index.js

```javascript
const urlParser = document.createElement('a')

export function domain (url) {
  urlParser.href = url
  return urlParser.hostname
}

export function fromNow (time) {
  const between = Date.now() / 1000 - Number(time)
  if (between < 3600) {
    return pluralize(~~(between / 60), ' minute')
  } else if (between < 86400) {
    return pluralize(~~(between / 3600), ' hour')
  } else {
    return pluralize(~~(between / 86400), ' day')
  }
}

function pluralize(time, label) {
    if (time === 1) {
        return time + label
    }

    return time + label + 's';
}

```

src/store/index.js

```javascript
import Firebase from 'firebase'
import { EventEmitter } from 'events'
import { Promise } from 'es6-promise'

const api = new Firebase('https://hacker-news.firebaseio.com/v0')
const itemsCache = Object.create(null)
const store = new EventEmitter()
const storiesPerPage = store.storiesPerPage = 30

let topStoryIds = []

export default store

```

####firebase介绍

[官方的一个5min入门介绍](https://www.firebase.com/tutorial/index.html#gettingstarted)


```javascript
/**
 * .child()是firebase的一个api接口，on是监听topstories下的值，
 * 若resolve,则触发'topstories-updated'事件
 */

api.child('topstories').on('value', snapshot => {
  topStoryIds = snapshot.val()
  store.emit('topstories-updated')
})
```
[具体请看HackerNews API](https://github.com/HackerNews/API)


```javascript
store.fetchItem = id => {
  return new Promise((resolve, reject) => {
    if (itemsCache[id]) {
      resolve(itemsCache[id])
    } else {
      api.child('item/' + id).once('value', snapshot => {
        const story = itemsCache[id] = snapshot.val()
        resolve(story)
      }, reject)
    }
  })
}

store.fetchUser = id => {
  return new Promise((resolve, reject) => {
    api.child('user/' + id).once('value', snapshot => {
      resolve(snapshot.val())
    }, reject)
  })
}
```
store.fetchItem/fetchUser返回一个Promise,如果缓存已经存在id了，则直接resolve([id]),不然就发个请求，获取其值成功后并存在itemsCache中，否则reject.


```javascript
store.fetchItems = ids => {
  if (!ids || !ids.length) {
    return Promise.resolve([])
  } else {
    return Promise.all(ids.map(id => store.fetchItem(id)))
  }
}

store.fetchItemsByPage = page => {
  const start = (page - 1) * storiesPerPage
  const end = page * storiesPerPage
  const ids = topStoryIds.slice(start, end)
  return store.fetchItems(ids)
}
```

Promise.all传入一个数组，数组里的每个Promise都resolve后，此Promise才可以resolve.
storiesPerPage 是一个常量，定义每一页显示的数量，然后返回一个Promise即fetchItems(ids)


